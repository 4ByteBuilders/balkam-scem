// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type Resource interface {
	IsResource()
	GetID() string
	GetName() string
	GetOwner() *User
	GetParent() *Folder
	GetCreatedAt() string
	GetUpdatedAt() string
	GetShareToken() string
	GetPermissions() []*Permission
	GetTags() []*Tag
}

type AuthPayload struct {
	Token string `json:"token"`
	User  *User  `json:"user"`
}

type File struct {
	ID          string        `json:"id"`
	Name        string        `json:"name"`
	Owner       *User         `json:"owner"`
	Parent      *Folder       `json:"parent,omitempty"`
	CreatedAt   string        `json:"createdAt"`
	UpdatedAt   string        `json:"updatedAt"`
	Permissions []*Permission `json:"permissions,omitempty"`
	Type        string        `json:"type"`
	ShareToken  string        `json:"shareToken"`
	SizeBytes   int           `json:"sizeBytes"`
	MimeType    string        `json:"mimeType"`
	Storage     *StorageStats `json:"storage"`
	Tags        []*Tag        `json:"tags"`
}

func (File) IsResource()                {}
func (this File) GetID() string         { return this.ID }
func (this File) GetName() string       { return this.Name }
func (this File) GetOwner() *User       { return this.Owner }
func (this File) GetParent() *Folder    { return this.Parent }
func (this File) GetCreatedAt() string  { return this.CreatedAt }
func (this File) GetUpdatedAt() string  { return this.UpdatedAt }
func (this File) GetShareToken() string { return this.ShareToken }
func (this File) GetPermissions() []*Permission {
	if this.Permissions == nil {
		return nil
	}
	interfaceSlice := make([]*Permission, 0, len(this.Permissions))
	for _, concrete := range this.Permissions {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this File) GetTags() []*Tag {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]*Tag, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Folder struct {
	ID          string        `json:"id"`
	Name        string        `json:"name"`
	Owner       *User         `json:"owner"`
	Parent      *Folder       `json:"parent,omitempty"`
	CreatedAt   string        `json:"createdAt"`
	UpdatedAt   string        `json:"updatedAt"`
	Permissions []*Permission `json:"permissions,omitempty"`
	Type        string        `json:"type"`
	ShareToken  string        `json:"shareToken"`
	Children    []Resource    `json:"children"`
	Tags        []*Tag        `json:"tags"`
}

func (Folder) IsResource()                {}
func (this Folder) GetID() string         { return this.ID }
func (this Folder) GetName() string       { return this.Name }
func (this Folder) GetOwner() *User       { return this.Owner }
func (this Folder) GetParent() *Folder    { return this.Parent }
func (this Folder) GetCreatedAt() string  { return this.CreatedAt }
func (this Folder) GetUpdatedAt() string  { return this.UpdatedAt }
func (this Folder) GetShareToken() string { return this.ShareToken }
func (this Folder) GetPermissions() []*Permission {
	if this.Permissions == nil {
		return nil
	}
	interfaceSlice := make([]*Permission, 0, len(this.Permissions))
	for _, concrete := range this.Permissions {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this Folder) GetTags() []*Tag {
	if this.Tags == nil {
		return nil
	}
	interfaceSlice := make([]*Tag, 0, len(this.Tags))
	for _, concrete := range this.Tags {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type Mutation struct {
}

type Permission struct {
	User *User `json:"user"`
	Role Role  `json:"role"`
}

type Query struct {
}

type SearchFilters struct {
	Name         *string  `json:"name,omitempty"`
	Types        []string `json:"types,omitempty"`
	MimeTypes    []string `json:"mimeTypes,omitempty"`
	MinSizeBytes *int     `json:"minSizeBytes,omitempty"`
	MaxSizeBytes *int     `json:"maxSizeBytes,omitempty"`
	AfterDate    *string  `json:"afterDate,omitempty"`
	BeforeDate   *string  `json:"beforeDate,omitempty"`
	Tags         []string `json:"tags,omitempty"`
	UploaderName *string  `json:"uploaderName,omitempty"`
}

type StorageStats struct {
	OriginalSizeBytes     int     `json:"originalSizeBytes"`
	DeduplicatedSizeBytes int     `json:"deduplicatedSizeBytes"`
	SavedBytes            int     `json:"savedBytes"`
	SavedPercentage       float64 `json:"savedPercentage"`
}

type Tag struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type User struct {
	ID                       string `json:"id"`
	Username                 string `json:"username"`
	Email                    string `json:"email"`
	Role                     string `json:"Role"`
	StorageUsed              int    `json:"StorageUsed"`
	DeduplicationStorageUsed int    `json:"DeduplicationStorageUsed"`
}

type UserResources struct {
	OwnerID       string     `json:"ownerId"`
	OwnerUsername string     `json:"ownerUsername"`
	Resources     []Resource `json:"resources"`
}

type Role string

const (
	RoleViewer Role = "VIEWER"
	RoleEditor Role = "EDITOR"
)

var AllRole = []Role{
	RoleViewer,
	RoleEditor,
}

func (e Role) IsValid() bool {
	switch e {
	case RoleViewer, RoleEditor:
		return true
	}
	return false
}

func (e Role) String() string {
	return string(e)
}

func (e *Role) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Role(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Role", str)
	}
	return nil
}

func (e Role) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Role) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Role) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
