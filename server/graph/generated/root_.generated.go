// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/bhavyajaix/BalkanID-filevault/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AuthPayload struct {
		Token func(childComplexity int) int
		User  func(childComplexity int) int
	}

	File struct {
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		MimeType    func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		Parent      func(childComplexity int) int
		Permissions func(childComplexity int) int
		SizeBytes   func(childComplexity int) int
		Storage     func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Folder struct {
		Children    func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		Parent      func(childComplexity int) int
		Permissions func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Mutation struct {
		CreateFolder     func(childComplexity int, name string, parentID *string) int
		DeleteResource   func(childComplexity int, id string) int
		GrantPermission  func(childComplexity int, resourceID string, userID string, role model.Role) int
		Login            func(childComplexity int, email string, password string) int
		MoveResource     func(childComplexity int, resourceID string, newParentID *string) int
		Register         func(childComplexity int, username string, email string, password string) int
		RenameResource   func(childComplexity int, id string, newName string) int
		RevokePermission func(childComplexity int, resourceID string, userID string) int
		UploadFile       func(childComplexity int, file graphql.Upload, parentID *string) int
	}

	Permission struct {
		Role func(childComplexity int) int
		User func(childComplexity int) int
	}

	Query struct {
		Me        func(childComplexity int) int
		Resource  func(childComplexity int, id string) int
		Resources func(childComplexity int, folderID *string) int
	}

	StorageStats struct {
		DeduplicatedSizeBytes func(childComplexity int) int
		OriginalSizeBytes     func(childComplexity int) int
		SavedBytes            func(childComplexity int) int
		SavedPercentage       func(childComplexity int) int
	}

	User struct {
		Email    func(childComplexity int) int
		ID       func(childComplexity int) int
		Username func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AuthPayload.token":
		if e.complexity.AuthPayload.Token == nil {
			break
		}

		return e.complexity.AuthPayload.Token(childComplexity), true

	case "AuthPayload.user":
		if e.complexity.AuthPayload.User == nil {
			break
		}

		return e.complexity.AuthPayload.User(childComplexity), true

	case "File.createdAt":
		if e.complexity.File.CreatedAt == nil {
			break
		}

		return e.complexity.File.CreatedAt(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.mimeType":
		if e.complexity.File.MimeType == nil {
			break
		}

		return e.complexity.File.MimeType(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.owner":
		if e.complexity.File.Owner == nil {
			break
		}

		return e.complexity.File.Owner(childComplexity), true

	case "File.parent":
		if e.complexity.File.Parent == nil {
			break
		}

		return e.complexity.File.Parent(childComplexity), true

	case "File.permissions":
		if e.complexity.File.Permissions == nil {
			break
		}

		return e.complexity.File.Permissions(childComplexity), true

	case "File.sizeBytes":
		if e.complexity.File.SizeBytes == nil {
			break
		}

		return e.complexity.File.SizeBytes(childComplexity), true

	case "File.storage":
		if e.complexity.File.Storage == nil {
			break
		}

		return e.complexity.File.Storage(childComplexity), true

	case "File.updatedAt":
		if e.complexity.File.UpdatedAt == nil {
			break
		}

		return e.complexity.File.UpdatedAt(childComplexity), true

	case "Folder.children":
		if e.complexity.Folder.Children == nil {
			break
		}

		return e.complexity.Folder.Children(childComplexity), true

	case "Folder.createdAt":
		if e.complexity.Folder.CreatedAt == nil {
			break
		}

		return e.complexity.Folder.CreatedAt(childComplexity), true

	case "Folder.id":
		if e.complexity.Folder.ID == nil {
			break
		}

		return e.complexity.Folder.ID(childComplexity), true

	case "Folder.name":
		if e.complexity.Folder.Name == nil {
			break
		}

		return e.complexity.Folder.Name(childComplexity), true

	case "Folder.owner":
		if e.complexity.Folder.Owner == nil {
			break
		}

		return e.complexity.Folder.Owner(childComplexity), true

	case "Folder.parent":
		if e.complexity.Folder.Parent == nil {
			break
		}

		return e.complexity.Folder.Parent(childComplexity), true

	case "Folder.permissions":
		if e.complexity.Folder.Permissions == nil {
			break
		}

		return e.complexity.Folder.Permissions(childComplexity), true

	case "Folder.updatedAt":
		if e.complexity.Folder.UpdatedAt == nil {
			break
		}

		return e.complexity.Folder.UpdatedAt(childComplexity), true

	case "Mutation.createFolder":
		if e.complexity.Mutation.CreateFolder == nil {
			break
		}

		args, err := ec.field_Mutation_createFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFolder(childComplexity, args["name"].(string), args["parentId"].(*string)), true

	case "Mutation.deleteResource":
		if e.complexity.Mutation.DeleteResource == nil {
			break
		}

		args, err := ec.field_Mutation_deleteResource_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteResource(childComplexity, args["id"].(string)), true

	case "Mutation.grantPermission":
		if e.complexity.Mutation.GrantPermission == nil {
			break
		}

		args, err := ec.field_Mutation_grantPermission_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GrantPermission(childComplexity, args["resourceId"].(string), args["userId"].(string), args["role"].(model.Role)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["email"].(string), args["password"].(string)), true

	case "Mutation.moveResource":
		if e.complexity.Mutation.MoveResource == nil {
			break
		}

		args, err := ec.field_Mutation_moveResource_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MoveResource(childComplexity, args["resourceId"].(string), args["newParentId"].(*string)), true

	case "Mutation.register":
		if e.complexity.Mutation.Register == nil {
			break
		}

		args, err := ec.field_Mutation_register_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Register(childComplexity, args["username"].(string), args["email"].(string), args["password"].(string)), true

	case "Mutation.renameResource":
		if e.complexity.Mutation.RenameResource == nil {
			break
		}

		args, err := ec.field_Mutation_renameResource_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RenameResource(childComplexity, args["id"].(string), args["newName"].(string)), true

	case "Mutation.revokePermission":
		if e.complexity.Mutation.RevokePermission == nil {
			break
		}

		args, err := ec.field_Mutation_revokePermission_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokePermission(childComplexity, args["resourceId"].(string), args["userId"].(string)), true

	case "Mutation.uploadFile":
		if e.complexity.Mutation.UploadFile == nil {
			break
		}

		args, err := ec.field_Mutation_uploadFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadFile(childComplexity, args["file"].(graphql.Upload), args["parentId"].(*string)), true

	case "Permission.role":
		if e.complexity.Permission.Role == nil {
			break
		}

		return e.complexity.Permission.Role(childComplexity), true

	case "Permission.user":
		if e.complexity.Permission.User == nil {
			break
		}

		return e.complexity.Permission.User(childComplexity), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.resource":
		if e.complexity.Query.Resource == nil {
			break
		}

		args, err := ec.field_Query_resource_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Resource(childComplexity, args["id"].(string)), true

	case "Query.resources":
		if e.complexity.Query.Resources == nil {
			break
		}

		args, err := ec.field_Query_resources_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Resources(childComplexity, args["folderId"].(*string)), true

	case "StorageStats.deduplicatedSizeBytes":
		if e.complexity.StorageStats.DeduplicatedSizeBytes == nil {
			break
		}

		return e.complexity.StorageStats.DeduplicatedSizeBytes(childComplexity), true

	case "StorageStats.originalSizeBytes":
		if e.complexity.StorageStats.OriginalSizeBytes == nil {
			break
		}

		return e.complexity.StorageStats.OriginalSizeBytes(childComplexity), true

	case "StorageStats.savedBytes":
		if e.complexity.StorageStats.SavedBytes == nil {
			break
		}

		return e.complexity.StorageStats.SavedBytes(childComplexity), true

	case "StorageStats.savedPercentage":
		if e.complexity.StorageStats.SavedPercentage == nil {
			break
		}

		return e.complexity.StorageStats.SavedPercentage(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `# A special scalar type that allows for file uploads.
scalar Upload

# Represents a user of the application.
type User {
  id: ID!
  username: String!
  email: String!
}

# The payload returned after a successful authentication.
type AuthPayload {
  token: String!
  user: User!
}

# Contains information about storage savings due to deduplication.
type StorageStats {
  originalSizeBytes: Int!
  deduplicatedSizeBytes: Int! # The actual space this file takes on disk
  savedBytes: Int!
  savedPercentage: Float!
}

# Defines the roles a user can have on a resource.
enum Role {
  VIEWER
  EDITOR
}

# Shows a user's specific permission level on a resource.
type Permission {
  user: User!
  role: Role!
}

# A generic interface for any item in the vault, whether a file or folder.
# This is the core of the new, unified schema.
interface Resource {
  id: ID!
  name: String!
  owner: User!
  parent: Folder # Parent is always a folder or null if root
  createdAt: String!
  updatedAt: String!
  # List of users who have explicit access to this resource.
  permissions: [Permission!]
}

# Represents a folder, which can contain other resources.
type Folder implements Resource {
  # Fields from the Resource interface
  id: ID!
  name: String!
  owner: User!
  parent: Folder
  createdAt: String!
  updatedAt: String!
  permissions: [Permission!]

  # Folder-specific field
  # Contains all the files and sub-folders within this folder.
  children: [Resource!]!
}

# Represents a file's metadata.
type File implements Resource {
  # Fields from the Resource interface
  id: ID!
  name: String!
  owner: User!
  parent: Folder
  createdAt: String!
  updatedAt: String!
  permissions: [Permission!]

  # File-specific fields
  sizeBytes: Int!
  mimeType: String!
  storage: StorageStats!
}

# The entry point for all read operations.
type Query {
  # Get the currently authenticated user's profile.
  me: User

  # Get a single resource by its ID. Can be a file or a folder.
  resource(id: ID!): Resource

  # Get the contents of a specific folder.
  # If folderId is null, it returns the user's root-level resources.
  resources(folderId: ID): [Resource!]!
}

# The entry point for all write/change operations.
type Mutation {
  # --- User management ---
  register(username: String!, email: String!, password: String!): AuthPayload!
  login(email: String!, password: String!): AuthPayload!

  # --- Resource operations ---
  uploadFile(file: Upload!, parentId: ID): File!
  createFolder(name: String!, parentId: ID): Folder!
  renameResource(id: ID!, newName: String!): Resource!
  deleteResource(id: ID!): Boolean!
  moveResource(resourceId: ID!, newParentId: ID): Resource!

  # --- Sharing and permissions ---
  grantPermission(resourceId: ID!, userId: ID!, role: Role!): Resource!
  revokePermission(resourceId: ID!, userId: ID!): Resource!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
