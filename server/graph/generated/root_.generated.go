// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/bhavyajaix/BalkanID-filevault/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AuthPayload struct {
		Token func(childComplexity int) int
		User  func(childComplexity int) int
	}

	File struct {
		DownloadCount   func(childComplexity int) int
		Filename        func(childComplexity int) int
		ID              func(childComplexity int) int
		IsPublic        func(childComplexity int) int
		MimeType        func(childComplexity int) int
		Owner           func(childComplexity int) int
		PublicShareLink func(childComplexity int) int
		SizeBytes       func(childComplexity int) int
		Storage         func(childComplexity int) int
		UploadedAt      func(childComplexity int) int
	}

	Folder struct {
		Children func(childComplexity int) int
		Files    func(childComplexity int) int
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		Owner    func(childComplexity int) int
		Parent   func(childComplexity int) int
	}

	Mutation struct {
		CreateFolder      func(childComplexity int, input model.NewFolderInput) int
		DeleteFile        func(childComplexity int, id string) int
		DeleteFolder      func(childComplexity int, id string) int
		Login             func(childComplexity int, email string, password string) int
		Register          func(childComplexity int, username string, email string, password string) int
		RevokeFilePublic  func(childComplexity int, id string) int
		ShareFilePublic   func(childComplexity int, id string) int
		UpdateFileDetails func(childComplexity int, id string, newFilename string) int
		UploadFile        func(childComplexity int, file graphql.Upload, folderID *string) int
	}

	Query struct {
		File      func(childComplexity int, id string) int
		Me        func(childComplexity int) int
		MyFiles   func(childComplexity int, filter *model.FileFilterInput) int
		MyFolders func(childComplexity int) int
	}

	StorageStats struct {
		DeduplicatedSizeBytes func(childComplexity int) int
		OriginalSizeBytes     func(childComplexity int) int
		SavedBytes            func(childComplexity int) int
		SavedPercentage       func(childComplexity int) int
	}

	User struct {
		Email    func(childComplexity int) int
		ID       func(childComplexity int) int
		Username func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AuthPayload.token":
		if e.complexity.AuthPayload.Token == nil {
			break
		}

		return e.complexity.AuthPayload.Token(childComplexity), true

	case "AuthPayload.user":
		if e.complexity.AuthPayload.User == nil {
			break
		}

		return e.complexity.AuthPayload.User(childComplexity), true

	case "File.downloadCount":
		if e.complexity.File.DownloadCount == nil {
			break
		}

		return e.complexity.File.DownloadCount(childComplexity), true

	case "File.filename":
		if e.complexity.File.Filename == nil {
			break
		}

		return e.complexity.File.Filename(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.isPublic":
		if e.complexity.File.IsPublic == nil {
			break
		}

		return e.complexity.File.IsPublic(childComplexity), true

	case "File.mimeType":
		if e.complexity.File.MimeType == nil {
			break
		}

		return e.complexity.File.MimeType(childComplexity), true

	case "File.owner":
		if e.complexity.File.Owner == nil {
			break
		}

		return e.complexity.File.Owner(childComplexity), true

	case "File.publicShareLink":
		if e.complexity.File.PublicShareLink == nil {
			break
		}

		return e.complexity.File.PublicShareLink(childComplexity), true

	case "File.sizeBytes":
		if e.complexity.File.SizeBytes == nil {
			break
		}

		return e.complexity.File.SizeBytes(childComplexity), true

	case "File.storage":
		if e.complexity.File.Storage == nil {
			break
		}

		return e.complexity.File.Storage(childComplexity), true

	case "File.uploadedAt":
		if e.complexity.File.UploadedAt == nil {
			break
		}

		return e.complexity.File.UploadedAt(childComplexity), true

	case "Folder.children":
		if e.complexity.Folder.Children == nil {
			break
		}

		return e.complexity.Folder.Children(childComplexity), true

	case "Folder.files":
		if e.complexity.Folder.Files == nil {
			break
		}

		return e.complexity.Folder.Files(childComplexity), true

	case "Folder.id":
		if e.complexity.Folder.ID == nil {
			break
		}

		return e.complexity.Folder.ID(childComplexity), true

	case "Folder.name":
		if e.complexity.Folder.Name == nil {
			break
		}

		return e.complexity.Folder.Name(childComplexity), true

	case "Folder.owner":
		if e.complexity.Folder.Owner == nil {
			break
		}

		return e.complexity.Folder.Owner(childComplexity), true

	case "Folder.parent":
		if e.complexity.Folder.Parent == nil {
			break
		}

		return e.complexity.Folder.Parent(childComplexity), true

	case "Mutation.createFolder":
		if e.complexity.Mutation.CreateFolder == nil {
			break
		}

		args, err := ec.field_Mutation_createFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFolder(childComplexity, args["input"].(model.NewFolderInput)), true

	case "Mutation.deleteFile":
		if e.complexity.Mutation.DeleteFile == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFile(childComplexity, args["id"].(string)), true

	case "Mutation.deleteFolder":
		if e.complexity.Mutation.DeleteFolder == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFolder(childComplexity, args["id"].(string)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["email"].(string), args["password"].(string)), true

	case "Mutation.register":
		if e.complexity.Mutation.Register == nil {
			break
		}

		args, err := ec.field_Mutation_register_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Register(childComplexity, args["username"].(string), args["email"].(string), args["password"].(string)), true

	case "Mutation.revokeFilePublic":
		if e.complexity.Mutation.RevokeFilePublic == nil {
			break
		}

		args, err := ec.field_Mutation_revokeFilePublic_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokeFilePublic(childComplexity, args["id"].(string)), true

	case "Mutation.shareFilePublic":
		if e.complexity.Mutation.ShareFilePublic == nil {
			break
		}

		args, err := ec.field_Mutation_shareFilePublic_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ShareFilePublic(childComplexity, args["id"].(string)), true

	case "Mutation.updateFileDetails":
		if e.complexity.Mutation.UpdateFileDetails == nil {
			break
		}

		args, err := ec.field_Mutation_updateFileDetails_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFileDetails(childComplexity, args["id"].(string), args["newFilename"].(string)), true

	case "Mutation.uploadFile":
		if e.complexity.Mutation.UploadFile == nil {
			break
		}

		args, err := ec.field_Mutation_uploadFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadFile(childComplexity, args["file"].(graphql.Upload), args["folderId"].(*string)), true

	case "Query.file":
		if e.complexity.Query.File == nil {
			break
		}

		args, err := ec.field_Query_file_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.File(childComplexity, args["id"].(string)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.myFiles":
		if e.complexity.Query.MyFiles == nil {
			break
		}

		args, err := ec.field_Query_myFiles_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MyFiles(childComplexity, args["filter"].(*model.FileFilterInput)), true

	case "Query.myFolders":
		if e.complexity.Query.MyFolders == nil {
			break
		}

		return e.complexity.Query.MyFolders(childComplexity), true

	case "StorageStats.deduplicatedSizeBytes":
		if e.complexity.StorageStats.DeduplicatedSizeBytes == nil {
			break
		}

		return e.complexity.StorageStats.DeduplicatedSizeBytes(childComplexity), true

	case "StorageStats.originalSizeBytes":
		if e.complexity.StorageStats.OriginalSizeBytes == nil {
			break
		}

		return e.complexity.StorageStats.OriginalSizeBytes(childComplexity), true

	case "StorageStats.savedBytes":
		if e.complexity.StorageStats.SavedBytes == nil {
			break
		}

		return e.complexity.StorageStats.SavedBytes(childComplexity), true

	case "StorageStats.savedPercentage":
		if e.complexity.StorageStats.SavedPercentage == nil {
			break
		}

		return e.complexity.StorageStats.SavedPercentage(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputFileFilterInput,
		ec.unmarshalInputNewFolderInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `# A special scalar type that allows for file uploads.
# Your GraphQL server library (like gqlgen) needs to be configured to handle this.
scalar Upload

# Represents a user of the application.
type User {
  id: ID!
  username: String!
  email: String!
}

# Contains information about storage savings due to deduplication.
type StorageStats {
  originalSizeBytes: Int!
  deduplicatedSizeBytes: Int! # The actual space this file takes on disk
  savedBytes: Int!
  savedPercentage: Float!
}

# Represents a folder in the user's vault.
type Folder {
  id: ID!
  name: String!
  owner: User!
  parent: Folder # A folder can be inside another folder; null if it's a root folder.
  children: [Folder!]! # Sub-folders
  files: [File!]! # Files within this folder
}

# Represents the user's view of a file and its metadata.
type File {
  id: ID!
  filename: String!
  owner: User!
  sizeBytes: Int!
  mimeType: String!
  uploadedAt: String! # Using String for simplicity; can be a custom DateTime scalar
  isPublic: Boolean!
  publicShareLink: String # Null if not public
  downloadCount: Int!
  storage: StorageStats! # Nested object for storage details
}

# Defines the inputs for filtering files in a query.
input FileFilterInput {
  filename: String
  mimeType: String
  minSize: Int
  maxSize: Int
  startDate: String
  endDate: String
}

# The entry point for all read operations.
type Query {
  # Get the currently authenticated user's profile.
  me: User

  # Get all files for the authenticated user, with optional filtering.
  myFiles(filter: FileFilterInput): [File!]!

  # Get a specific file by its ID.
  file(id: ID!): File

  # Get the folder structure for the authenticated user.
  myFolders: [Folder!]!
}

# Defines the inputs for creating a new folder.
input NewFolderInput {
  name: String!
  # The ID of the parent folder. If null, creates a root folder.
  parentFolderId: ID
}

# The payload returned after a successful authentication.
type AuthPayload {
  token: String!
  user: User!
}

# The entry point for all write/change operations.
type Mutation {
  # User management
  register(username: String!, email: String!, password: String!): AuthPayload!
  login(email: String!, password: String!): AuthPayload!

  # File operations
  uploadFile(file: Upload!, folderId: ID): File!
  deleteFile(id: ID!): Boolean! # Returns true on success
  updateFileDetails(id: ID!, newFilename: String!): File!

  # Folder operations
  createFolder(input: NewFolderInput!): Folder!
  deleteFolder(id: ID!): Boolean!

  # Sharing operations
  shareFilePublic(id: ID!): String! # Returns the public URL
  revokeFilePublic(id: ID!): File! # Returns the updated file object
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
