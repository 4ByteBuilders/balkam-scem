// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/bhavyajaix/BalkanID-filevault/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AuthPayload struct {
		Token func(childComplexity int) int
		User  func(childComplexity int) int
	}

	File struct {
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		MimeType    func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		Parent      func(childComplexity int) int
		Permissions func(childComplexity int) int
		ShareToken  func(childComplexity int) int
		SizeBytes   func(childComplexity int) int
		Storage     func(childComplexity int) int
		Tags        func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Folder struct {
		Children    func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Owner       func(childComplexity int) int
		Parent      func(childComplexity int) int
		Permissions func(childComplexity int) int
		ShareToken  func(childComplexity int) int
		Tags        func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Mutation struct {
		AddTagToResource      func(childComplexity int, resourceID string, tagName string) int
		CreateFolder          func(childComplexity int, name string, parentID *string) int
		DeleteFile            func(childComplexity int, id string) int
		DeleteFolder          func(childComplexity int, id string) int
		GrantPermission       func(childComplexity int, resourceID string, email string, role model.Role) int
		Login                 func(childComplexity int, email string, password string) int
		MoveFile              func(childComplexity int, fileID string, newParentID *string) int
		MoveFolder            func(childComplexity int, folderID string, newParentID *string) int
		Register              func(childComplexity int, username string, email string, password string) int
		RemoveTagFromResource func(childComplexity int, resourceID string, tagID string) int
		RenameFile            func(childComplexity int, id string, newName string) int
		RenameFolder          func(childComplexity int, id string, newName string) int
		RevokePermission      func(childComplexity int, resourceID string, email string) int
		UploadFile            func(childComplexity int, file graphql.Upload, parentID *string) int
	}

	Permission struct {
		Role func(childComplexity int) int
		User func(childComplexity int) int
	}

	Query struct {
		File             func(childComplexity int, id string) int
		Folder           func(childComplexity int, id string) int
		Me               func(childComplexity int) int
		ResolveShareLink func(childComplexity int, token string) int
		Resources        func(childComplexity int, folderID *string) int
	}

	StorageStats struct {
		DeduplicatedSizeBytes func(childComplexity int) int
		OriginalSizeBytes     func(childComplexity int) int
		SavedBytes            func(childComplexity int) int
		SavedPercentage       func(childComplexity int) int
	}

	Tag struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	User struct {
		Email    func(childComplexity int) int
		ID       func(childComplexity int) int
		Username func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AuthPayload.token":
		if e.complexity.AuthPayload.Token == nil {
			break
		}

		return e.complexity.AuthPayload.Token(childComplexity), true

	case "AuthPayload.user":
		if e.complexity.AuthPayload.User == nil {
			break
		}

		return e.complexity.AuthPayload.User(childComplexity), true

	case "File.createdAt":
		if e.complexity.File.CreatedAt == nil {
			break
		}

		return e.complexity.File.CreatedAt(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.mimeType":
		if e.complexity.File.MimeType == nil {
			break
		}

		return e.complexity.File.MimeType(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.owner":
		if e.complexity.File.Owner == nil {
			break
		}

		return e.complexity.File.Owner(childComplexity), true

	case "File.parent":
		if e.complexity.File.Parent == nil {
			break
		}

		return e.complexity.File.Parent(childComplexity), true

	case "File.permissions":
		if e.complexity.File.Permissions == nil {
			break
		}

		return e.complexity.File.Permissions(childComplexity), true

	case "File.shareToken":
		if e.complexity.File.ShareToken == nil {
			break
		}

		return e.complexity.File.ShareToken(childComplexity), true

	case "File.sizeBytes":
		if e.complexity.File.SizeBytes == nil {
			break
		}

		return e.complexity.File.SizeBytes(childComplexity), true

	case "File.storage":
		if e.complexity.File.Storage == nil {
			break
		}

		return e.complexity.File.Storage(childComplexity), true

	case "File.tags":
		if e.complexity.File.Tags == nil {
			break
		}

		return e.complexity.File.Tags(childComplexity), true

	case "File.type":
		if e.complexity.File.Type == nil {
			break
		}

		return e.complexity.File.Type(childComplexity), true

	case "File.updatedAt":
		if e.complexity.File.UpdatedAt == nil {
			break
		}

		return e.complexity.File.UpdatedAt(childComplexity), true

	case "Folder.children":
		if e.complexity.Folder.Children == nil {
			break
		}

		return e.complexity.Folder.Children(childComplexity), true

	case "Folder.createdAt":
		if e.complexity.Folder.CreatedAt == nil {
			break
		}

		return e.complexity.Folder.CreatedAt(childComplexity), true

	case "Folder.id":
		if e.complexity.Folder.ID == nil {
			break
		}

		return e.complexity.Folder.ID(childComplexity), true

	case "Folder.name":
		if e.complexity.Folder.Name == nil {
			break
		}

		return e.complexity.Folder.Name(childComplexity), true

	case "Folder.owner":
		if e.complexity.Folder.Owner == nil {
			break
		}

		return e.complexity.Folder.Owner(childComplexity), true

	case "Folder.parent":
		if e.complexity.Folder.Parent == nil {
			break
		}

		return e.complexity.Folder.Parent(childComplexity), true

	case "Folder.permissions":
		if e.complexity.Folder.Permissions == nil {
			break
		}

		return e.complexity.Folder.Permissions(childComplexity), true

	case "Folder.shareToken":
		if e.complexity.Folder.ShareToken == nil {
			break
		}

		return e.complexity.Folder.ShareToken(childComplexity), true

	case "Folder.tags":
		if e.complexity.Folder.Tags == nil {
			break
		}

		return e.complexity.Folder.Tags(childComplexity), true

	case "Folder.type":
		if e.complexity.Folder.Type == nil {
			break
		}

		return e.complexity.Folder.Type(childComplexity), true

	case "Folder.updatedAt":
		if e.complexity.Folder.UpdatedAt == nil {
			break
		}

		return e.complexity.Folder.UpdatedAt(childComplexity), true

	case "Mutation.addTagToResource":
		if e.complexity.Mutation.AddTagToResource == nil {
			break
		}

		args, err := ec.field_Mutation_addTagToResource_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddTagToResource(childComplexity, args["resourceID"].(string), args["tagName"].(string)), true

	case "Mutation.createFolder":
		if e.complexity.Mutation.CreateFolder == nil {
			break
		}

		args, err := ec.field_Mutation_createFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFolder(childComplexity, args["name"].(string), args["parentId"].(*string)), true

	case "Mutation.deleteFile":
		if e.complexity.Mutation.DeleteFile == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFile(childComplexity, args["id"].(string)), true

	case "Mutation.deleteFolder":
		if e.complexity.Mutation.DeleteFolder == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFolder(childComplexity, args["id"].(string)), true

	case "Mutation.grantPermission":
		if e.complexity.Mutation.GrantPermission == nil {
			break
		}

		args, err := ec.field_Mutation_grantPermission_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GrantPermission(childComplexity, args["resourceId"].(string), args["email"].(string), args["role"].(model.Role)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["email"].(string), args["password"].(string)), true

	case "Mutation.moveFile":
		if e.complexity.Mutation.MoveFile == nil {
			break
		}

		args, err := ec.field_Mutation_moveFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MoveFile(childComplexity, args["fileId"].(string), args["newParentId"].(*string)), true

	case "Mutation.moveFolder":
		if e.complexity.Mutation.MoveFolder == nil {
			break
		}

		args, err := ec.field_Mutation_moveFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MoveFolder(childComplexity, args["folderId"].(string), args["newParentId"].(*string)), true

	case "Mutation.register":
		if e.complexity.Mutation.Register == nil {
			break
		}

		args, err := ec.field_Mutation_register_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Register(childComplexity, args["username"].(string), args["email"].(string), args["password"].(string)), true

	case "Mutation.removeTagFromResource":
		if e.complexity.Mutation.RemoveTagFromResource == nil {
			break
		}

		args, err := ec.field_Mutation_removeTagFromResource_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveTagFromResource(childComplexity, args["resourceID"].(string), args["tagID"].(string)), true

	case "Mutation.renameFile":
		if e.complexity.Mutation.RenameFile == nil {
			break
		}

		args, err := ec.field_Mutation_renameFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RenameFile(childComplexity, args["id"].(string), args["newName"].(string)), true

	case "Mutation.renameFolder":
		if e.complexity.Mutation.RenameFolder == nil {
			break
		}

		args, err := ec.field_Mutation_renameFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RenameFolder(childComplexity, args["id"].(string), args["newName"].(string)), true

	case "Mutation.revokePermission":
		if e.complexity.Mutation.RevokePermission == nil {
			break
		}

		args, err := ec.field_Mutation_revokePermission_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokePermission(childComplexity, args["resourceId"].(string), args["email"].(string)), true

	case "Mutation.uploadFile":
		if e.complexity.Mutation.UploadFile == nil {
			break
		}

		args, err := ec.field_Mutation_uploadFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadFile(childComplexity, args["file"].(graphql.Upload), args["parentId"].(*string)), true

	case "Permission.role":
		if e.complexity.Permission.Role == nil {
			break
		}

		return e.complexity.Permission.Role(childComplexity), true

	case "Permission.user":
		if e.complexity.Permission.User == nil {
			break
		}

		return e.complexity.Permission.User(childComplexity), true

	case "Query.file":
		if e.complexity.Query.File == nil {
			break
		}

		args, err := ec.field_Query_file_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.File(childComplexity, args["id"].(string)), true

	case "Query.folder":
		if e.complexity.Query.Folder == nil {
			break
		}

		args, err := ec.field_Query_folder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Folder(childComplexity, args["id"].(string)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.resolveShareLink":
		if e.complexity.Query.ResolveShareLink == nil {
			break
		}

		args, err := ec.field_Query_resolveShareLink_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ResolveShareLink(childComplexity, args["token"].(string)), true

	case "Query.resources":
		if e.complexity.Query.Resources == nil {
			break
		}

		args, err := ec.field_Query_resources_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Resources(childComplexity, args["folderId"].(*string)), true

	case "StorageStats.deduplicatedSizeBytes":
		if e.complexity.StorageStats.DeduplicatedSizeBytes == nil {
			break
		}

		return e.complexity.StorageStats.DeduplicatedSizeBytes(childComplexity), true

	case "StorageStats.originalSizeBytes":
		if e.complexity.StorageStats.OriginalSizeBytes == nil {
			break
		}

		return e.complexity.StorageStats.OriginalSizeBytes(childComplexity), true

	case "StorageStats.savedBytes":
		if e.complexity.StorageStats.SavedBytes == nil {
			break
		}

		return e.complexity.StorageStats.SavedBytes(childComplexity), true

	case "StorageStats.savedPercentage":
		if e.complexity.StorageStats.SavedPercentage == nil {
			break
		}

		return e.complexity.StorageStats.SavedPercentage(childComplexity), true

	case "Tag.createdAt":
		if e.complexity.Tag.CreatedAt == nil {
			break
		}

		return e.complexity.Tag.CreatedAt(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "Tag.updatedAt":
		if e.complexity.Tag.UpdatedAt == nil {
			break
		}

		return e.complexity.Tag.UpdatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `# A special scalar type that allows for file uploads.
scalar Upload

# Represents a user of the application.
type User {
  id: ID!
  username: String!
  email: String!
}

# The payload returned after a successful authentication.
type AuthPayload {
  token: String!
  user: User!
}

# Contains information about storage savings due to deduplication.
type StorageStats {
  originalSizeBytes: Int!
  deduplicatedSizeBytes: Int! # The actual space this file takes on disk
  savedBytes: Int!
  savedPercentage: Float!
}

# Defines the roles a user can have on a resource.
enum Role {
  VIEWER
  EDITOR
}

# Shows a user's specific permission level on a resource.
type Permission {
  user: User!
  role: Role!
}

type Tag {
  id: ID!
  name: String!
  createdAt: String!
  updatedAt: String!
}

# A generic interface for any item in the vault, whether a file or folder.
# This is the core of the new, unified schema.
interface Resource {
  id: ID!
  name: String!
  owner: User!
  parent: Folder # Parent is always a folder or null if root
  createdAt: String!
  updatedAt: String!
  shareToken: String!
  # List of users who have explicit access to this resource.
  permissions: [Permission!]
  tags: [Tag!]!
}

# Represents a folder, which can contain other resources.
type Folder implements Resource {
  # Fields from the Resource interface
  id: ID!
  name: String!
  owner: User!
  parent: Folder
  createdAt: String!
  updatedAt: String!
  permissions: [Permission!]
  type: String!
  shareToken: String!

  # Folder-specific field
  # Contains all the files and sub-folders within this folder.
  children: [Resource!]!
  tags: [Tag!]!
}

# Represents a file's metadata.
type File implements Resource {
  # Fields from the Resource interface
  id: ID!
  name: String!
  owner: User!
  parent: Folder
  createdAt: String!
  updatedAt: String!
  permissions: [Permission!]
  type: String!
  shareToken: String!

  # File-specific fields
  sizeBytes: Int!
  mimeType: String!
  storage: StorageStats!
  tags: [Tag!]!
}

# The entry point for all read operations.
type Query {
  # Get the currently authenticated user's profile.
  me: User

  # --- NEW: Specific queries for files and folders ---
  # Get a single file by its ID.
  file(id: ID!): File
  # Get a single folder by its ID.
  folder(id: ID!): Folder
  # NEW: Resolves a share token to a resource, performing an auth check.
  resolveShareLink(token: String!): Resource
  # Get the contents of a specific folder.
  # If folderId is null, it returns the user's root-level resources.
  resources(folderId: ID): [Resource!]!
}

# The entry point for all write/change operations.
type Mutation {
  # --- User management ---
  register(username: String!, email: String!, password: String!): AuthPayload!
  login(email: String!, password: String!): AuthPayload!

  # --- File and Folder creation ---
  uploadFile(file: Upload!, parentId: ID): File!
  createFolder(name: String!, parentId: ID): Folder!

  # --- NEW: Specific mutations for files ---
  renameFile(id: ID!, newName: String!): File!
  deleteFile(id: ID!): Boolean!
  moveFile(fileId: ID!, newParentId: ID): File!

  # --- NEW: Specific mutations for folders ---
  renameFolder(id: ID!, newName: String!): Folder!
  deleteFolder(id: ID!): Boolean!
  moveFolder(folderId: ID!, newParentId: ID): Folder!

  # --- Sharing and permissions (still generic) ---
  grantPermission(resourceId: ID!, email: String!, role: Role!): Resource!
  revokePermission(resourceId: ID!, email: String!): Resource!

  # --- Tagging Files and Folders for efficient search
  addTagToResource(resourceID: ID!, tagName: String!): Resource!
  removeTagFromResource(resourceID: ID!, tagID: ID!): Resource!

}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
