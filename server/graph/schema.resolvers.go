package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/bhavyajaix/BalkanID-filevault/graph/generated"
	"github.com/bhavyajaix/BalkanID-filevault/graph/model"
	"github.com/bhavyajaix/BalkanID-filevault/internal/database"
	fileservice "github.com/bhavyajaix/BalkanID-filevault/internal/file"
	"github.com/bhavyajaix/BalkanID-filevault/internal/middleware"
	"github.com/bhavyajaix/BalkanID-filevault/internal/search"
	"github.com/bhavyajaix/BalkanID-filevault/pkg/auth"
	"github.com/bhavyajaix/BalkanID-filevault/pkg/utils"
)

func toGqlResource(dbRes *database.Resource) (model.Resource, error) {
	if dbRes == nil {
		return nil, errors.New("cannot convert nil resource")
	}

	owner := &model.User{
		ID:       fmt.Sprint(dbRes.User.ID),
		Username: dbRes.User.Username,
		Email:    dbRes.User.Email,
	}

	switch dbRes.Type {
	case database.Folder:
		return &model.Folder{
			ID:        fmt.Sprint(dbRes.ID),
			Name:      dbRes.Name,
			Owner:     owner,
			CreatedAt: dbRes.CreatedAt.String(),
			UpdatedAt: dbRes.UpdatedAt.String(),
			Type:      string(dbRes.Type),
		}, nil
	case database.File:
		return &model.File{
			ID:        fmt.Sprint(dbRes.ID),
			Name:      dbRes.Name,
			Owner:     owner,
			CreatedAt: dbRes.CreatedAt.String(),
			UpdatedAt: dbRes.UpdatedAt.String(),
			Type:      string(dbRes.Type),
			SizeBytes: int(dbRes.PhysicalFile.SizeBytes),
			MimeType:  string(dbRes.PhysicalFile.MimeType),
		}, nil
	default:
		return nil, fmt.Errorf("unknown resource type: %s", dbRes.Type)
	}
}
func toGqlPermission(dbRes *database.Resource) (model.Resource, error) {
	if dbRes == nil {
		return nil, errors.New("cannot convert nil resource")
	}

	owner := &model.User{
		ID:       fmt.Sprint(dbRes.User.ID),
		Username: dbRes.User.Username,
		Email:    dbRes.User.Email,
	}

	switch dbRes.Type {
	case database.Folder:
		return &model.Folder{
			ID:        fmt.Sprint(dbRes.ID),
			Name:      dbRes.Name,
			Owner:     owner,
			CreatedAt: dbRes.CreatedAt.String(),
			UpdatedAt: dbRes.UpdatedAt.String(),
			Type:      string(dbRes.Type),
		}, nil
	case database.File:
		return &model.File{
			ID:        fmt.Sprint(dbRes.ID),
			Name:      dbRes.Name,
			Owner:     owner,
			CreatedAt: dbRes.CreatedAt.String(),
			UpdatedAt: dbRes.UpdatedAt.String(),
			Type:      string(dbRes.Type),
		}, nil
	default:
		return nil, fmt.Errorf("unknown resource type: %s", dbRes.Type)
	}
}
func getUserIDFromContext(ctx context.Context) (uint, error) {
	userID, ok := ctx.Value(middleware.UserContextKey).(uint)
	if !ok {
		return 0, errors.New("unauthorized: access denied")
	}
	return userID, nil
}

// Register is the resolver for the register field. (Unchanged)
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string) (*model.AuthPayload, error) {
	dbUser, err := r.UserService.Register(username, email, password)
	if err != nil {
		return nil, err
	}
	token, err := auth.GenerateToken(dbUser.ID)
	if err != nil {
		return nil, fmt.Errorf("could not generate token after registration: %w", err)
	}
	gqlUser := &model.User{
		ID:       fmt.Sprint(dbUser.ID),
		Username: dbUser.Username,
		Email:    dbUser.Email,
	}
	return &model.AuthPayload{
		Token: token,
		User:  gqlUser,
	}, nil
}

// Login is the resolver for the login field. (Unchanged)
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	dbUser, token, err := r.UserService.Login(email, password)
	if err != nil {
		return nil, err
	}
	gqlUser := &model.User{
		ID:       fmt.Sprint(dbUser.ID),
		Username: dbUser.Username,
		Email:    dbUser.Email,
	}
	return &model.AuthPayload{
		Token: token,
		User:  gqlUser,
	}, nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, file graphql.Upload, parentID *string) (*model.File, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var pID *uint
	if parentID != nil {
		id, err := utils.StringToUint(*parentID)
		if err != nil {
			return nil, errors.New("invalid parentId format")
		}
		pID = &id
	}

	// Simply create the params struct and pass the arguments directly
	uploadParams := fileservice.UploadParams{
		Upload:   file, // Pass the whole file object
		OwnerID:  userID,
		ParentID: pID,
	}

	dbResource, err := r.FileService.UploadFile(uploadParams)
	if err != nil {
		return nil, err
	}

	gqlResource, err := toGqlResource(dbResource)
	if err != nil {
		return nil, err
	}

	gqlFile, ok := gqlResource.(*model.File)
	if !ok {
		return nil, errors.New("internal error: created resource was not a file")
	}

	return gqlFile, nil
}

// CreateFolder is the resolver for the createFolder field.
func (r *mutationResolver) CreateFolder(ctx context.Context, name string, parentID *string) (*model.Folder, error) {
	var pID *uint
	if parentID != nil {
		id, err := utils.StringToUint(*parentID)
		if err != nil {
			return nil, errors.New("invalid parentId")
		}
		pID = &id
	}

	dbFolder, err := r.FolderService.CreateFolder(ctx, name, pID)
	if err != nil {
		return nil, err
	}

	// We know this is a folder, so we can cast it.
	gqlFolder, err := toGqlResource(dbFolder)
	if err != nil {
		return nil, err
	}
	return gqlFolder.(*model.Folder), nil
}

// RenameFile is the resolver for the renameFile field.
func (r *mutationResolver) RenameFile(ctx context.Context, id string, newName string) (*model.File, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	resID, err := utils.StringToUint(id)
	if err != nil {
		return nil, errors.New("invalid id format")
	}

	dbResource, err := r.FileService.RenameFile(resID, userID, newName)
	if err != nil {
		return nil, err
	}

	gqlResource, err := toGqlResource(dbResource)
	if err != nil {
		return nil, err
	}

	gqlFile, ok := gqlResource.(*model.File)
	if !ok {
		return nil, errors.New("internal error: renamed resource was not a file")
	}

	return gqlFile, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, id string) (bool, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	resID, err := utils.StringToUint(id)
	if err != nil {
		return false, errors.New("invalid id format")
	}

	err = r.FileService.DeleteFile(resID, userID)
	return err == nil, err
}

// MoveFile is the resolver for the moveFile field.
func (r *mutationResolver) MoveFile(ctx context.Context, fileID string, newParentID *string) (*model.File, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	resID, err := utils.StringToUint(fileID)
	if err != nil {
		return nil, errors.New("invalid fileId format")
	}

	var parentID *uint
	if newParentID != nil {
		pID, err := utils.StringToUint(*newParentID)
		if err != nil {
			return nil, errors.New("invalid newParentId format")
		}
		parentID = &pID
	}

	dbResource, err := r.FileService.MoveFile(resID, userID, parentID)
	if err != nil {
		return nil, err
	}

	gqlResource, err := toGqlResource(dbResource)
	if err != nil {
		return nil, err
	}

	gqlFile, ok := gqlResource.(*model.File)
	if !ok {
		return nil, errors.New("internal error: moved resource was not a file")
	}

	return gqlFile, nil
}

// RenameFolder is the resolver for the renameFolder field.
func (r *mutationResolver) RenameFolder(ctx context.Context, id string, newName string) (*model.Folder, error) {
	// 1. Convert the string ID to a uint
	resID, err := utils.StringToUint(id)
	if err != nil {
		return nil, errors.New("invalid id format")
	}
	// 2. Call the service to perform the business logic
	// Note: I've corrected this to call ResourceService
	dbResource, err := r.FolderService.RenameResource(ctx, resID, newName)
	if err != nil {
		return nil, err
	}

	// 3. Convert the updated database model to the generic GraphQL interface
	gqlResource, err := toGqlResource(dbResource)
	if err != nil {
		return nil, err
	}

	// 4. Assert that the returned resource is specifically a Folder
	gqlFolder, ok := gqlResource.(*model.Folder)
	if !ok {
		// This is an internal error; your service returned a file when we expected a folder.
		return nil, errors.New("error: expected a folder but received a different type")
	}
	return gqlFolder, nil
}

// DeleteFolder is the resolver for the deleteFolder field.
func (r *mutationResolver) DeleteFolder(ctx context.Context, id string) (bool, error) {
	resID, err := utils.StringToUint(id)
	if err != nil {
		return false, errors.New("invalid id format")
	}
	err = r.FolderService.DeleteResource(ctx, resID)
	return err == nil, err
}

// MoveFolder is the resolver for the moveFolder field.
func (r *mutationResolver) MoveFolder(ctx context.Context, folderID string, newParentID *string) (*model.Folder, error) {
	// 1. Convert the required folderID
	resID, err := utils.StringToUint(folderID)
	if err != nil {
		return nil, errors.New("invalid folderId format")
	}

	// 2. Handle the optional newParentID
	var parentID *uint
	if newParentID != nil {
		pID, err := utils.StringToUint(*newParentID)
		if err != nil {
			return nil, errors.New("invalid newParentId format")
		}
		parentID = &pID
	}

	// 3. Call the service (Corrected to ResourceService)
	dbResource, err := r.FolderService.MoveResource(ctx, resID, parentID)
	if err != nil {
		return nil, err
	}

	// 4. Convert the result to the generic interface
	gqlResource, err := toGqlResource(dbResource)
	if err != nil {
		return nil, err
	}

	// 5. Assert that the interface value is specifically a *model.Folder
	gqlFolder, ok := gqlResource.(*model.Folder)
	if !ok {
		return nil, errors.New("error: expected a folder but received a different type")
	}

	return gqlFolder, nil
}

// GrantPermission is the resolver for the grantPermission field.
func (r *mutationResolver) GrantPermission(ctx context.Context, resourceID string, email string, role model.Role) (model.Resource, error) {
	resID, err := utils.StringToUint(resourceID)
	if err != nil {
		return nil, errors.New("invalid resourceId format")
	}

	// Convert the GraphQL Role enum to your database RoleType string
	dbRole := database.RoleType(role.String())

	updatedResource, err := r.PermissionService.GrantPermission(ctx, resID, email, dbRole)
	if err != nil {
		return nil, err
	}

	return toGqlPermission(updatedResource)
}

// RevokePermission is the resolver for the revokePermission field.
func (r *mutationResolver) RevokePermission(ctx context.Context, resourceID string, email string) (model.Resource, error) {
	// 1. Decode the string ID into a uint
	resID, err := utils.StringToUint(resourceID)
	if err != nil {
		return nil, errors.New("invalid resourceId format")
	}

	// 2. Call the service to handle the business logic and database operations
	updatedResource, err := r.PermissionService.RevokePermission(ctx, resID, email)
	if err != nil {
		return nil, err
	}

	// 3. Encode the database model into the GraphQL model for the response
	return toGqlPermission(updatedResource)
}

// AddTagToResource is the resolver for the addTagToResource field.
func (r *mutationResolver) AddTagToResource(ctx context.Context, resourceID string, tagName string) (model.Resource, error) {
	// 1. Parse GraphQL string ID to uint
	id, err := strconv.ParseUint(resourceID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid resource ID format")
	}

	// 2. Call the service to perform the business logic
	resource, err := r.Resolver.TagService.AddTag(uint(id), tagName)
	if err != nil {
		return nil, err // The service will return a descriptive error
	}

	// 3. Convert to GraphQL model and return the result
	gqlResource, err := toGqlResource(resource)
	if err != nil {
		return nil, err
	}
	return gqlResource, nil
}

// RemoveTagFromResource is the resolver for the removeTagFromResource field.
func (r *mutationResolver) RemoveTagFromResource(ctx context.Context, resourceID string, tagID string) (model.Resource, error) {
	// 1. Parse IDs
	resID, err := strconv.ParseUint(resourceID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid resource ID format")
	}
	tID, err := strconv.ParseUint(tagID, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid tag ID format")
	}

	// 2. Call the service
	resource, err := r.Resolver.TagService.RemoveTag(uint(resID), uint(tID))
	if err != nil {
		return nil, err
	}

	// 3. Convert to GraphQL model and return the result
	gqlResource, err := toGqlResource(resource)
	if err != nil {
		return nil, err
	}
	return gqlResource, nil
}

// Me is the resolver for the me field. (Unchanged)
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := ctx.Value(middleware.UserContextKey).(uint)
	if !ok {
		return nil, errors.New("unauthorized: access denied")
	}
	dbUser, err := r.UserService.GetUserByID(userID)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       fmt.Sprint(dbUser.ID),
		Username: dbUser.Username,
		Email:    dbUser.Email,
	}, nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, id string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: File - file"))
}

// Folder is the resolver for the folder field.
func (r *queryResolver) Folder(ctx context.Context, id string) (*model.Folder, error) {
	panic(fmt.Errorf("not implemented: Folder - folder"))
}

// ResolveShareLink is the resolver for the resolveShareLink field.
func (r *queryResolver) ResolveShareLink(ctx context.Context, token string) (model.Resource, error) {
	dbResource, err := r.ShareService.ResolveShareLink(ctx, token)
	if err != nil {
		return nil, err
	}
	return toGqlResource(dbResource)
}

// Resources is the resolver for the resources field.
func (r *queryResolver) Resources(ctx context.Context, folderID *string) ([]model.Resource, error) {
	var pID *uint
	if folderID != nil {
		id, err := utils.StringToUint(*folderID)
		if err != nil {
			return nil, errors.New("invalid folderId")
		}
		pID = &id
	}

	dbResources, err := r.FolderService.GetResources(ctx, pID)
	if err != nil {
		return nil, err
	}
	var gqlResources []model.Resource
	for _, dbRes := range dbResources {
		// Use the helper to convert each resource
		gqlRes, err := toGqlResource(&dbRes)
		if err == nil { // Skip resources that fail to convert
			gqlResources = append(gqlResources, gqlRes)
		}
	}
	return gqlResources, nil
}

// SearchResources is the resolver for the searchResources field.
func (r *queryResolver) SearchResources(ctx context.Context, filters model.SearchFilters, offset *int, limit *int) ([]model.Resource, error) {
	// 1. Map the GraphQL input model to your internal service model
	// This keeps your service layer decoupled from the GraphQL schema.
	serviceFilters := search.SearchFilters{
		Name:         filters.Name,
		Types:        filters.Types,
		MimeTypes:    filters.MimeTypes,
		Tags:         filters.Tags,
	}

	if filters.UploaderName != nil {
    	serviceFilters.UploaderName = filters.UploaderName
	}

	// Handle pointers for optional fields
	if filters.MinSizeBytes != nil {
		minSize := int64(*filters.MinSizeBytes)
		serviceFilters.MinSizeBytes = &minSize
	}
	if filters.MaxSizeBytes != nil {
		maxSize := int64(*filters.MaxSizeBytes)
		serviceFilters.MaxSizeBytes = &maxSize
	}
	if filters.AfterDate != nil {
		after, _ := time.Parse(time.RFC3339, *filters.AfterDate)
		serviceFilters.AfterDate = &after
	}
	if filters.BeforeDate != nil {
		before, _ := time.Parse(time.RFC3339, *filters.BeforeDate)
		serviceFilters.BeforeDate = &before
	}

	// Use default pagination if not provided
	pagination := search.Pagination{Offset: 0, Limit: 25}
	if offset != nil {
		pagination.Offset = *offset
	}
	if limit != nil {
		pagination.Limit = *limit
	}

	// 2. Call the service layer
	// The service will handle getting the current user from the context and applying security rules.
	dbResources, err := r.SearchService.Search(ctx, serviceFilters, pagination)
	if err != nil {
		return nil, err
	}

	// 3. Convert your database models back to GraphQL models using your helper
	gqlResources := make([]model.Resource, 0, len(dbResources))
	for _, dbRes := range dbResources {
		gqlRes, err := toGqlResource(&dbRes) // Use your existing helper
		if err == nil {
			gqlResources = append(gqlResources, gqlRes)
		}
	}

	return gqlResources, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func toGqlResource(dbRes *database.Resource) (model.Resource, error) {
	if dbRes == nil {
		return nil, errors.New("cannot convert nil resource")
	}

	owner := &model.User{
		ID:       fmt.Sprint(dbRes.User.ID),
		Username: dbRes.User.Username,
		Email:    dbRes.User.Email,
	}

	switch dbRes.Type {
	case database.Folder:
		return &model.Folder{
			ID:        fmt.Sprint(dbRes.ID),
			Name:      dbRes.Name,
			Owner:     owner,
			CreatedAt: dbRes.CreatedAt.String(),
			UpdatedAt: dbRes.UpdatedAt.String(),
			Type:      string(dbRes.Type),
		}, nil
	case database.File:
		return &model.File{
			ID:        fmt.Sprint(dbRes.ID),
			Name:      dbRes.Name,
			Owner:     owner,
			CreatedAt: dbRes.CreatedAt.String(),
			UpdatedAt: dbRes.UpdatedAt.String(),
			Type:      string(dbRes.Type),
			SizeBytes: int(dbRes.PhysicalFile.SizeBytes),
			MimeType:  string(dbRes.PhysicalFile.MimeType),
		}, nil
	default:
		return nil, fmt.Errorf("unknown resource type: %s", dbRes.Type)
	}
}
func toGqlPermission(dbRes *database.Resource) (model.Resource, error) {
	if dbRes == nil {
		return nil, errors.New("cannot convert nil resource")
	}

	owner := &model.User{
		ID:       fmt.Sprint(dbRes.User.ID),
		Username: dbRes.User.Username,
		Email:    dbRes.User.Email,
	}

	switch dbRes.Type {
	case database.Folder:
		return &model.Folder{
			ID:        fmt.Sprint(dbRes.ID),
			Name:      dbRes.Name,
			Owner:     owner,
			CreatedAt: dbRes.CreatedAt.String(),
			UpdatedAt: dbRes.UpdatedAt.String(),
			Type:      string(dbRes.Type),
		}, nil
	case database.File:
		return &model.File{
			ID:        fmt.Sprint(dbRes.ID),
			Name:      dbRes.Name,
			Owner:     owner,
			CreatedAt: dbRes.CreatedAt.String(),
			UpdatedAt: dbRes.UpdatedAt.String(),
			Type:      string(dbRes.Type),
		}, nil
	default:
		return nil, fmt.Errorf("unknown resource type: %s", dbRes.Type)
	}
}
func getUserIDFromContext(ctx context.Context) (uint, error) {
	userID, ok := ctx.Value(middleware.UserContextKey).(uint)
	if !ok {
		return 0, errors.New("unauthorized: access denied")
	}
	return userID, nil
}
*/
