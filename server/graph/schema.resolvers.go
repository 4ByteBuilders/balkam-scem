package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"errors"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/bhavyajaix/BalkanID-filevault/graph/generated"
	"github.com/bhavyajaix/BalkanID-filevault/graph/model"
	"github.com/bhavyajaix/BalkanID-filevault/internal/middleware"
	"github.com/bhavyajaix/BalkanID-filevault/pkg/auth"
)

// Register is the resolver for the register field. (Unchanged)
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string) (*model.AuthPayload, error) {
	dbUser, err := r.UserService.Register(username, email, password)
	if err != nil {
		return nil, err
	}
	token, err := auth.GenerateToken(dbUser.ID)
	if err != nil {
		return nil, fmt.Errorf("could not generate token after registration: %w", err)
	}
	gqlUser := &model.User{
		ID:       fmt.Sprint(dbUser.ID),
		Username: dbUser.Username,
		Email:    dbUser.Email,
	}
	return &model.AuthPayload{
		Token: token,
		User:  gqlUser,
	}, nil
}

// Login is the resolver for the login field. (Unchanged)
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	dbUser, token, err := r.UserService.Login(email, password)
	if err != nil {
		return nil, err
	}
	gqlUser := &model.User{
		ID:       fmt.Sprint(dbUser.ID),
		Username: dbUser.Username,
		Email:    dbUser.Email,
	}
	return &model.AuthPayload{
		Token: token,
		User:  gqlUser,
	}, nil
}

// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, file graphql.Upload, parentID *string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: UploadFile - needs to call ResourceService.CreateFile"))
}

// CreateFolder is the resolver for the createFolder field.
func (r *mutationResolver) CreateFolder(ctx context.Context, name string, parentID *string) (*model.Folder, error) {
	panic(fmt.Errorf("not implemented: CreateFolder - needs to call ResourceService.CreateFolder"))
}

// RenameResource is the resolver for the renameResource field.
func (r *mutationResolver) RenameResource(ctx context.Context, id string, newName string) (model.Resource, error) {
	panic(fmt.Errorf("not implemented: RenameResource - needs to call ResourceService.Rename"))
}

// DeleteResource is the resolver for the deleteResource field.
func (r *mutationResolver) DeleteResource(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteResource - needs to call ResourceService.Delete"))
}

// MoveResource is the resolver for the moveResource field.
func (r *mutationResolver) MoveResource(ctx context.Context, resourceID string, newParentID *string) (model.Resource, error) {
	panic(fmt.Errorf("not implemented: MoveResource - needs to call ResourceService.Move"))
}

// GrantPermission is the resolver for the grantPermission field.
func (r *mutationResolver) GrantPermission(ctx context.Context, resourceID string, userID string, role model.Role) (model.Resource, error) {
	panic(fmt.Errorf("not implemented: GrantPermission - needs to call PermissionService.Grant"))
}

// RevokePermission is the resolver for the revokePermission field.
func (r *mutationResolver) RevokePermission(ctx context.Context, resourceID string, userID string) (model.Resource, error) {
	panic(fmt.Errorf("not implemented: RevokePermission - needs to call PermissionService.Revoke"))
}

// Me is the resolver for the me field. (Unchanged)
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := ctx.Value(middleware.UserContextKey).(uint)
	if !ok {
		return nil, errors.New("unauthorized: access denied")
	}
	dbUser, err := r.UserService.GetUserByID(userID)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:       fmt.Sprint(dbUser.ID),
		Username: dbUser.Username,
		Email:    dbUser.Email,
	}, nil
}

// Resource is the resolver for the resource field.
func (r *queryResolver) Resource(ctx context.Context, id string) (model.Resource, error) {
	panic(fmt.Errorf("not implemented: Resource - needs to call ResourceService.GetByID"))
}

// Resources is the resolver for the resources field.
func (r *queryResolver) Resources(ctx context.Context, folderID *string) ([]model.Resource, error) {
	panic(fmt.Errorf("not implemented: Resources - needs to call ResourceService.GetChildren"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *folderResolver) Children(ctx context.Context, obj *model.Folder) ([]model.Resource, error) {
	// ⚠️ This is a classic N+1 problem. Use a Dataloader here!
	// The resolver should call your ResourceService to get children for obj.ID
	panic(fmt.Errorf("not implemented: Children - needs to call ResourceService.GetChildren"))
}
func (r *resourceResolver) Permissions(ctx context.Context, obj model.Resource) ([]*model.Permission, error) {
    // This is another potential N+1 problem. Use a Dataloader!
    // This resolver should call your PermissionService to get permissions for obj.ID()
    panic(fmt.Errorf("not implemented: Permissions - needs to call PermissionService.GetPermissionsForResource"))
}
func (r *Resolver) Folder() generated.FolderResolver { return &folderResolver{r} }
func (r *Resolver) Resource() generated.ResourceResolver { return &resourceResolver{r} }
type folderResolver struct{ *Resolver }
type resourceResolver struct { *Resolver }
*/
